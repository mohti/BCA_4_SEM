<resources>
    <string name="app_name">BCA 4 Sem</string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="unit_name_goes_here">unit name goes here</string>

<!--    COA UNIT 1 STRINGS-->

    <string name="traid">\n “TRIAD” \n\n A computer system can be defined as a TRIAD comprising of three fundamental components:\n
(1) The CPU (2) The Memory and (3) The I/O \n\n
These three devices communicates with each other with the help of a set of wires called System Bus,
where the System Bus comprises of three buses as –\n
1. The Address Bus\n
2. The Data Bus and\n
3. The Control Bus.\n\n
A computer system requires an interface with the user to execute a program. The interaction is
accomplished with the help of I/O devices. (The Input – Output subsystem of a computer, referred to
as I/O, provides an efficient mode of communication between the central system and the outside
environment).\n\n</string>
    <string name="IOheading">
        <html><u><b>Input – Output Architecture</b></u> \n\n</html>
A computer system organization is defined as a collection of component connected together in a
logical sense, i.e. the logical structure of a computer system is termed computer organization.
The collection of physical component such as CPU, Memory, I/O arranged constitutes computer
architecture. Thus the physical definition of the system is architecture.
\n\n
Organization = Logical\n
Architecture = Physical\n\n</string>
    <string name="systemHeading">\nThe I/O devices are connected to an entity called an interface (I/F) to have
            an interaction with the system.\n\n</string>
    <string name="organisation">\n
     <u>  <b>Organization and Architecture→</b></u> \n\n
In describing computer system, a distinction is often made between computer architecture and
computer organization. Computer architecture refers to those attributes of a system visible to a
programmer or put another way, those attributes that have a direct impact on the logical execution
of a program. Computer organization refers to the operational units and their interconnections that
realize the architectural specifications. Example of architectural attributes include the instruction
set, the number of bits used to represent various data types (e.g. numbers, characters), I/O
mechanisms, and techniques for addressing memories. Organizational attributes include those
hardware details transparent to the programmer, such as control signals, interface between the
computer and peripherals and the memory technology used.
Register transfer language\n
A digital system is an interconnection of digital hardware modules combined together to
perform a specific processing task. The modules are constructed using registers ,decoders,
arithmetic elements and control logic. These various modules are interconnected with
common data and control paths to form a digital computer system.\n
A digital module can be best defined as the register it contains and the operations that are
performed on the data stored in them. The operations executed on data stored in registers
are called micro operations. A micro-operation is defined as an elementary operation
carried out on one clock pulse, over the information stored in one or more registers.eg.
shift, count, clear load.\n
The organization of a digital computer can be best defined by:\n
1)The set of registers it contains and their function\n
2)sequence of micro-operations performed on the data stored in the registers\n
3)control functions that initiate the sequence of micro-operations.\n
The symbolic notations used to describe the micro-operation transfers among registers is
called a register transfer language. As a programming language is a procedure for writing
symbols to specify a given computational process similarly a register transfer language ia a
system for expressing the micro-operation sequences in a symbolical form among the
registers of a digital module. Unlike a programming language; a register transfer language is
directly related to and cannot be separated from the registers and other hardware that it
defines.\n\n
\n\n<u><b>INTER-REGISTER TRANSFER</b></u>
Data transfer among registers is accomplished by means of inter-register transfer microoperations. These micro-operations perform a direct transfer of binary information from
one register to another. The destination register receives the information from the source
register retaining the contents in source register.\n
Information transfer from one register to the another can be performed either in parallel or
in serial.\n\n
        <u><b>Parallel transfer</b></u>\n\n
Parallel transfer is a simultaneous transfer of all bits from the source register to destination
register and is accomplished during one clock pulse. This micro-operation is designated in
symbolic form as follows:\n\n
A←B\n\n
And denotes a transfer of the content of register B into register A.The binary function which
determines when this transfer will take place is called a control function.A control function
is a binary function that is it can be either equal to 0 or 1.Thus the modified symbology for
the above transfer can be written as\n\n
P:A←B\n\n
The control function P symbolizes the fact that the stated micro-operation is executed by
the hardware only if P=1.\n</string>

    <string name="Basic_symbol">Understanding the basic symbols for the register transfer language\n\n
1. Capital letters are used to denote registers and subscripts denote individual cells of the register.eg A, B.\n\n
2.Paranthesis used to denote a portion of a register.eg. I (1-5), MBR(AD)\n\n
3.Arrow must be present in every micro-operation statement and denotes a transfer of the content of the register listed on the right side of the arrow into the register listed on the left side of the arrow.\n\n
4.Colon denotes a control function and the comma is used to separate two or more micro-operations when executed at the same time.\n
        Eg. F:A←B,B←A\n\n

        <b>SERIAL TRANSFER</b>\n\n
For serial transfer, both the source and destination registers are shift-registers.The information is transferred one bit at a time by shifting the bits out of the source register into the destination register. In order not to lose the information stored in the source register it is necessary that the information shifted out of the source register be circulated and shifted back at the same time.\n\n
The serial transfer of information from Reg B to Reg A is done with shift registers as shown in the block diagram of fig 2.Both the registers A and B are 4-bit registers.The serial output of reg B comes from the output of the rightmost flip-flop B4 .The serial input of reg A goes into the left-most flip-flop A1.When the shift-right control S=1,and a clock pulse occurs,the content of reg A and B are shifted once to the right and the value of B4 transferred to flip-flops A1 and B1.Due to this one bit is transferred from B to A and at the same time one bit is circulated back to reg B.\n\n

        The symbolical notation for the transfer is as follows:\n\n
S:A1←B4,B1←B4,Ai←Ai-1,Bi←Bi-1   where, i=2,3,4\n\n
S:A←B,B←B\n\n
    </string>
    <string name="Bus_transfer">\n\n<b>BUS TRANSFER</b>\n\n
In a system with N registers, the transfer from each register to another register requires lines to be connected from the output of each flip-flop in the source register to input of each flip-flop in the destination register.\n
The fig below shows transfer of data among 3 registers R1, R2, R3. There are six data paths between these 3 registers. If each register consists of N flip-flops, there is a need of 6n lines for parallel transfer from one reg to another. As the number of register increases the number of lines also increases many-folds.\n\n
    </string>
    <string name="below_bus">However, if one register is allowed to transfer at a time, we can reduce the number of lines as shown in the next fig where the output and input of each flip-flop of the register is connected to a common line through an electronic circuit that acts like a switch. All the switches are OPEN until a transfer is required. For a transfer of R1R3, switch S3 when closed transfers data from R3 to BUS and then switch S6 when closed transfers the data from BUS to R1.
This scheme can be extended to registers with n flip -flops and require n common lines since each flip-flop of the register must be connected to one common line.\n\n
Bus system of data transfer using four registers\n\n
A group of wires through which binary information is transferred among registers is called a BUS.\n\n
A bus system is formed with multiplexer circuits. A multiplexer selects data from many lines and directs it to a single output line. The fig shows how four registers are connected through multiplexers to form one set of common bus lines. Each register has 4 bits. Each 4X1 multiplexer has four data input lines, two selection lines, and one output line. Reg A is connected to I0 of the multiplexers, Reg B to I1 and so forth. The selection lines act as control to all the multiplexers such that if xy =00, multiplexer inputs I0 are selected and transferred to the output bus, i.e. 4-bit contents of reg A are transferred to the common bus. Activating the load input of a particular register will cause a transfer of information from the bus into register. When zw=00/01/10/11 then data gets transferred from bus to resp registerA/B/C/D.\n\n
        xy =10 : BUS←C\n\n
        zw=01 : R1(A)←BUS\n\n
    </string>
    <string name="memory_transfer">\n<b>Memory Transfer</b>\n\n
The transfer of information from memory to the external environment is called a Read Operation.\n\n
The transfer of information into the memory is called a write operation. In both operations, the particular memory word selected must be specified by an address. MAR a memory address register is connected to the address terminals of the memory.\n\n
A read micro-operation is a transfer from the selected memory register M into MBR.\n\n
MBR←M\n\n
This causes a transfer of one word into MBR from the selected mem reg M whose address is given by the address in MAR.\n\n</string>


    <string name="A_write_micro_operation">\n A write micro-operation is a transfer from MBR to the selected memory word M.This is shown symbolically as\n\n
M←MBR\n\n
This causes the transfer of a word from MBR into the mem reg M whose address is given by the address in MAR.\n\n
MBR←M[R1]\n\n
Denotes a read operation from the memory word whose address is specified by the reg R1.\n\n

ARITHMETIC MICRO-OPERATIONS\n\n
ALU (Arithmetic and Logic Unit) –\n\n\n
        <b>Arithmetic Circuit:</b>\n\n</string>

    <string name="The_ALU">\n
The ALU, Arithmetic and Logic Unit carry out the arithmetic and logic functions over the content of operands stored in register and memory. The general arithmetic functions are: addition, subtraction, increment, decrement etc.; whereas negotiation, AND, OR, XOR are the general logical operations that are carried out by this unit. An ALU is associated with a set of micro – instructions where every micro – instruction carried out a specific task.\n\n
</string>

    <string name="Arithmetic_Circuit">\n
<b>Arithmetic Circuit:</b> A binary parallel adder can be used to perform some fundamental arithmetic operation over the operands. Thus, a simple arithmetic circuit can be constructed with the help of parallel adder and by providing different inputs in form of A, B and Ci, many arithmetic operations can be carried out. Some fundamental arithmetic operations can be obtained by a parallel adder is shown in figure –\n\n
</string>

    <string name="Logic">\n
        <b><u>Logic Circuit:</u></b></string>

    <string name="Logic_Circuit">\n
<b><u>Logic Circuit:</u></b> A logic unit basically carries out logical operations over the content of CPU registers. The given figure illustrates a simple logic circuit created with the help of some fundamental gates and a multiplexer. The circuit accepts two inputs Ai and Bi (a bit of value A and value B) and with reference to control S1 and S0, perform a relevant logic operations as depicted in table. When S1, S0 equals 00, the unit produces A.B output.\n\n

This one stage of the logic circuit can be repeated n number of times to carry out logic operation over n – bit data.\n\n

<u><b>Truth table for 16 functions of two variables</b></u>
</string>

    <string name="F0">\n
F0=All 0’s \n\n
F1=x and y \n\n
F2=xy’ \n\n
F3=xy’+xy=x(y+y’)=x \n\n
F4=x’y \n\n
F5=x’y+xy=y(x’+x)=y \n\n
F6=x xor y \n\n
F7=x or y \n\n
F8=x nor y \n\n
F9=x xnor y \n\n
F10=x’y’+xy’=y’(x’+x)=y’ \n\n
F11=x’y’+xy’+xy=y’+xy \n\n
F12=x’y’+x’y=x’(y’+y)=x’ \n\n
F13=x’y’+x’y+xy=x’+xy \n\n
F14=x nand y \n\n
F15=All 1’s \n\n

<u><b>Arithmetic and Logic Unit –</b></u>\n\n
</string>

    <string name="The_ALU_can">\n
The ALU can be constructed by simply combining the arithmetic unit along with the logic unit to carry out the arithmetic and logic operations. Figure illustrate a typical ALU where it comprises of one stage of arithmetic unit and one stage of logic unit connected to a 2x1 multiplexer. The circuit now has an additional control S2 which selects one of the operation i.e., arithmetic or logic produced at output. On whole the circuit now comprises of three controls S2, S1 and S0 that selects a arithmetic or logic operation. The arithmetic operation selection is also depending on the carry input Ci. The table below shows all the operations that are carried out in the above circuit.\n\n
</string>


<string name="CONTROL_FUNCTIONS">\n
<u><b>CONTROL FUNCTIONS</b></u>\n\n
    The timig of all registers in a synchronous digital system is controlled by a master clock generator,whose clock pulse are applied to all flip-flops in the system. The binary variables that control the enable inputs of registers are called control functions.\n\n
    The hardware control network that generates control functions can be organized in three different ways\n\n
    1) As a sequential circuit\n
    2) As a sequence of timing signals coupled with control conditions\n
    3) As a control memory\n\n
    <u><b>TIMING SEQUENCES</b></u>\n\n
    Timing signals that control the sequence of operations in a digital computer can be generated with a binary counter and a decoder.\n\n
    </string>

    <string name="Generation">\n
<u><b>Generation of control functions</b></u>\n\n

    \n\n
    Each computer cycle is associated with a sequence of micro-operations. These micro-operations are controlled by the timing signals and other binary conditions in the system .The Boolean functions that generate the control decisions are the control functions.For eg\n\n
    T1: MBR←M\n\n
    T1=read-control input for memory unit\n\n
    FT1+R’T3: A←B\n\n
    The control function being a Boolean function can be generated with logic gates as shown in the fig below. The gates that generate the control function go to the load input of reg A to initiate the transfer. The condition may also initiate the same transfer.\n
</string>

    <string name="BASIC_COMPUTER">\n
<u><b>BASIC COMPUTER ORGANIZATION AND DESIGN</b></u>\n\n
    <b>Instruction codes</b>\n\n

    The internal organization of a computer system is defined by the sequence of micro-operations it performs on data stored in registers. A digital computer is a general purpose digital system. The user of such a system can control the process by means of a
    program, that is a set of instructions that specifies the operations, operands and the sequence by which processing has to occur.\n\n
    An instruction code is a group of bits that tell the computer to perform a specific operation. It is usually divided into more than one field ,the most basic of them being the operation field. The operation field specifies operations such as add, sub, shift left, logical and etc.\n\n
    At this point we must clearly understand the relation between an operation and a micro-operation. An operation is a part of an instruction stored in computer memory. It is a binary code that tells the computer to perform a specific operation. The control unit receives the instruction from memory and interprets the operation code bits. It then issues a sequence of control functions that perform micro-operations in internal computer registers. For every operation code, the control issues a sequence of micro-operations needed for the hardware implementation of the specified operation. Due to this reason operation code is also referred to as macro-operation because it specifies a set of micro-operations.\n\n
    Fig depicts an organization. Instructions are stored in one section of memory and data in another. For a memory unit with 4096 words we need 12 bits for address since 212 =4096. If we store each instruction code in one 16-bit memory word, then we have four bits available for 16 possible operations and 12 bits to specify the address of the operand over which the operation will execute.\n\n
</string>

    <string name="Demonstration">\n
<u><b>Demonstration of direct and indirect instructions</b></u>\n\n

    It is sometimes convenient to use the address bits of an instruction code not as an address but as the actual operand. When the second part of an instruction code specifies an operand, the instruction is said to have an immediate operand. When the second part specifies the address of an operand, the instruction is said to have a direct address. The third possibility is an indirect address, where the bits in the second part of the instruction designate an address of a memory word in which the address of the operand is found. The MSB generally differentiates between a direct or an indirect instruction format.\n\n
    To illustrate the concept let us take an example of an instruction code format\n\n
    It consists of a three-bit operation code designated by OP, a six-bit address part designated by AD, and an indirect-address mode designated by I. If I=0 it designates a direct address and if a 1 indicates indirect address.\n\n
    A direct address instruction is shown in fig.2(b). It is placed in address 2 in memory. The I bit is 0,so the instruction is recognized as a direct address instruction. Since the address part Ad is equal to binary equivalent of 9(001001),the control finds the operand in memory at address 9. In fig 2(c) I=1 ,therefore it is a indirect address instruction. The address part is 9 so the control goes to 9 and finds the address of operand. The indirect address instruction needs two references to memory to fetch an operand.\n\n
</string>

    <string name="Computer_Instructions">\n
<u><b>Computer Instructions</b></u>\n\n

    Computer instructions are stored in consecutive memory locations and are executed sequentially one at a time. The control reads an instruction from a specific address in memory and executes it and then continues onto the next instruction in sequence and so on. Memory words cannot communicate with the processor directly without going through an address and buffer register. It is also necessary to provide a register in control unit for storing operation codes after they are read from memory.\n\n
</string>

    <string name="The_memory">\n

The memory unit has a capacity of 4096 words and each word contains 16 bits. Twelve words are needed to specify the address of an operand. This leaves four bits for the operation part of the instruction. However, only 3 bits will be used to specify the operation code. Where the fourth bit will be used as a direct an indirect address bit. The memory buffer register (MBR) consists of 16 bits ,as does the accumulator register. The E register is an extension of the accumulator and will be used during shift operations for end around carry. The I register has a single cell for storing the mode bit and the operation register OPR stores the three-bit operation code from memory.\n\n
The memory address register (MAR)has 12 bits storing the 12 bit of the address. The program counter(PC) is also 12 bit long since it stores the address of the next address to be fetched by the processor. This register goes through a counting sequence and causes the computer to read sequential instructions stored in memory.\n\n
To read an instruction, the content of PC is transferred to MAR, a memory read cycle is initiated, and the PC is incremented by 1.This place the instruction code into MBR and prepares PC for the address of the next instruction. The operation code is transferred to OPR, the mode bit into I and the address part into MAR.\n\n
The basic computer has three different instruction code formats. The operation part contains three bits; the meaning of the remaining thirteen bits depends on the operation code encountered.\n\n
</string>

    <string name="A_computer_should">\n
A computer should have all the necessary and sufficient operations to carry out any conceivable processing task. It should contain instructions in each of the following categories:\n\n
1. Arithmetic, logic, and shift micro operations\n
2. Instructions for moving info to and from memory and processor registers\n
3. Instruction that check status info to provide decision making capabilities.\n
4. Input and output instructions.\n
5. The capability of stopping computer.\n\n

<b>TIMING and CONTROL</b>\n\n

When an instruction is read from memory, the computer is said to be in an instruction fetch cycle. When the word read from memory is an address of an operand the computer is in an indirect cycle. When the word read from the memory is an operand, the computer is in a data execute cycle. It is the function of the control to keep track of the various cycles.\n\n
The control unit uses two flip-flops to distinguish between the three cycles. These flip-flops are denoted by the letters F and R. A 2X4 decoder associated with these flip-flops provide four outputs , three of which can be used to differentiate between the above mentioned cycles.\n\n
The block diagram of the control unit for the basic computer is show in fig. The timing in the computer is generated by a 2-bit sequence counter(SC) and a 2X4 decoder. The timing signals out of the decoder are designated by t0,t1,t2 and t3.\n\n
</string>

    <string name="TIMING"><u><b>TIMING and CONTROL</b></u>\n\n</string>

    <string name="A_digital">\n
A digital computer operates over a given set of instructions to accomplish a problem solution. The instruction comprises of a sequence of micro operations that are needed to be carried out when the instruction is executed.\n\n
The unit of CPU that generates the sequence of micro operations for a given instruction is termed timing and control unit. A simple computer system CPU comprises of four machine cycle: Fetch Cycle, Indirect Cycle, Execute Cycle and Interrupt Cycle.\n\n
Figure illustrates a typical control unit block diagram. It consist of a control logic circuit associated with several functional blocks generating various control functions for a given instruction. It consists of following:\n\n
1. 3 x 8 Decoder: It accepts the three bit operation code of instruction and accordingly generate control signals q0……….q7. For example, if OPr is 011 than q3 is enable.\n\n
2. I: It is the indirect flip – flop that accept a value from I field of instruction. If I is 1 than q7 is determine. If q7 is 1 than an I–O instruction is carried out. If I is 0 and q7 is 1 than a register operation is carried out.\n\n
3. 2 x 4 Timing Decoder: This decoder provides four clocks t0 – t3, i.e., every cycle comprises of four clocks. This decoder is driven by the sequence counter SC and by a enable flip – flop S. if S is 1 than only the cycle is executed.\n\n
4. 2 x 4 Decoder (Control 2 x4 Decoder): This decoder accepts F and R bits and depending on their values generates the respective cycle as depicted in table.\n\n
C0 t0 : MAR ← PC\n\n
C0 t1 : MBR ← M, PC ← PC + 1\n\n
C0 t2 : OPR ← MBR (OP), I ← MBR (2)\n\n
q\'7 IC0t3 : R ← 1\n\n
(q7 + I\’) C0t3 : F ← 1\n\n</string>
    <string name="Fetch_Cycle">\n
<b>Fetch Cycle:</b> It is the first machine cycle of every instruction cycle. The task of this cycle is to fetch the instruction from the memory, to decode it and then to call the relevant machine cycle as either executes cycle or indirect cycle. The various tasks performed in fetch cycle at different clocks are shown above. In first clock to the content of program counter is transfer to MAR. In second clock t1, two tasks are carried out, i.e. the program counter is incremented by one as well as the memory location is read out in MBR. In third clock t2, the I and OP fields are filled up from fetched instruction. In fourth clock t3, the design is taken to call indirect cycle or execute cycle. This design is based on q7 and I. if q7 = 0 and I = 1 then indirect cycle is called else the execute cycle is called.\n\n
<b>Indirect cycle:</b>\n\n

C1 t0 : MAR ← MBR (ADDR)\n\n
C1 t1 : MBR ← M\n\n
C1 t2 : NOP\n\n
C1 t3 : F ← 1, R ← 0\n\n</string>

<string name="The_indirect">\n
The indirect cycle is used to fetch the address of operand. The indirect cycle receives the pointer value from fetch cycle. In the given machine C1 represents the indirect cycle. On the first clock of this machine cycle the address part obtained from the fetch cycle is used to get the address of operand, it is done in second cycle. The third cycle is NOP (No OPeration). The fourth cycle is used to call the execute cycle.\n\n

<u>ADD to AC (Accumulator)</u>\n\n
q1 C2 t0 : MAR ← MBR (AD)\n\n
q1 C2 t1 : MBR ← M\n\n
q1 C2 t2 : EAC ← AC + MBR\n\n
q1 c2 t3 : Fetch Cycle Call\n\n
<b>Instruction Cycle:</b>
An instruction cycle is a composition of various machine cycles. The general machine cycles are:\n\n
1. Fetch instruction\n\n
2. Decode instruction\n\n
3. Fetch Operand if any\n\n
4. Store results.\n\n
Every machine cycle in term is a composition of clocks where on each clock micro operations are carried out.\n\n
</string>

    <string name="Interrupts"><u>Interrupts</u> –\n
An interrupt is a signalling mechanism by which the external entity or the internal program itself can as the CPU to perform some special services that are dedicates routines or called Interrupt Service Routine (ISR).\n\n
A computer system comprises of two types of interrupt called the Hardware Interrupt and Software Interrupt. The interrupt that are generated over the pin of a CPU (Microprocessor) are termed hardware interrupt whereas the interrupt generated programmatically are termed software interrupt.\n\n
The interrupt may be vector or non – vector. If the service routine address of an interrupt is fixed that is assign with a fixed address than is called a non – vector interrupt else if the address of interrupt is provided by the interrupting device than it is called a vector interrupt.\n\n
Figure illustrates a flow chart for interrupt handling. Initially the CPU waits for an instruction. When an instruction is submitted the fetch and execute cycles are performed i.e. the instruction cycle is carried out. At the end of instruction cycle the interrupt status is checked. If more than one interrupts are there than their priority are resolved and the interrupt with highest priority is served.\n\n
Calling an executive interrupt service routine:\n\n
Once the interrupt is identified the CPU saves the content of register onto the stack, transfer the control to ISR, disable interrupts, and services interrupt enable the interrupt and reload the saved register values and contents.\n\n
</string>

<!--    GRAPHICS UNIT 1 STRINGS-->

    <string name="graphics_unit_1_part_1">
        <b>►What is Computer Graphics?</b>\n\n
Computer graphics is an art of drawing pictures, lines, charts, etc using computers with the help of programming. Computer graphics is made up of number of pixels. \n\n


<b>What are the Types of Computer Graphics :-</b>\n\n
        <b>1. Interactive computer graphics</b> \n
        a two way communication between the computer
and the user ,where the observer is given some control over the image by providing
an input device example video games  \n\n

        <b>2.Non -Interactive computer graphics (passive computer graphics)-</b>\n
here  the user does not have any kind of control over the image .
the image is product of static stored program and will work according to
the instructions given in the program .here the image is totally
under the control of program instruction not under the user
Example - screensaver.\n\n

        <b>►Pixel:-</b> the smallest addressable screen element or smallest addressable area which we can control on the screen at some point of time is called pixel\n\n
        <b>►Resolution:-</b>the number of points that can be displayed without overlapping each other on the screen is defined as resolution. \n\n\

<b>►Aspect ratio :-</b> it is a ratio of vertical length by horizontal length
of any object in term of the number of pixel present\n\n\n
    </string>
    <string name="graphics_unit_1_part_2"><b>►Graphics workStation :-</b></string>\n\n
    <string name="graphics_unit_1_part_3">
        •it is a graphical kernel system term for a graphical
device that can display graphical output and accept graphical input\n
•It consists of cpu ,display,processer ,memory,display device
,recorder,plotter,keyboard,mouse,scanner,etc..\n
•The main hardware component of a graphics workstation are
cpu and display processor.\n
•The display processor is also called graphics controller or a
a display co-processor.\n
•It makes cpu free from the graphical work.\n
•In addition to the system memory a seperate display procesor
 memory area is provided.\n
• The graphical workstation have a provision to interface
video games and television set\n
• They also have display devices with very high resolution and
very high performance cpu.\n
•The graphical workstation is always supported with graphical
software.\n\n\n
</string>

    <string name="graphics_unit_1_part_4">

        <b>►Random Scan and Raster Scan Display:</b>\n\n
        <b>1.Random Scan Display:</b>\n\n
        Random Scan System uses an electron beam which operates like a pencil to create a line image on the CRT screen. The picture is constructed out of a sequence of straight-line segments. Each line segment is drawn on the screen by directing the beam to move from one point on the screen to the next, where its x and y coordinates define each point. After drawing the picture. The system cycles back to the first line and design all the lines of the image 30 to 60 time each second. \n\n
        Random-scan monitors are also known as vector displays or stroke-writing displays or calligraphic displays.\n\n\n

        <b>Advantages:</b>\n\n
•A CRT has the electron beam directed only to the parts of the screen where an image is to be drawn.\n
•Produce smooth line drawings.\n
•High Resolution\n\n
<b>Disadvantages:</b>\n\n
•Random-Scan monitors cannot display realistic shades scenes.\n\n\n
            </string>

    <string name="graphics_unit_1_part_5">
    <b>2.Raster Scan Display:</b>\n\n
A Raster Scan Display is based on intensity control of pixels in the form of a rectangular box called Raster on the screen. Information of on and off pixels is stored in refresh buffer or Frame buffer. Televisions in our house are based on Raster Scan Method. The raster scan system can store information of each pixel position, so it is suitable for realistic display of objects. Raster Scan provides a refresh rate of 60 to 80 frames per second.\n
Frame Buffer is also known as Raster or bit map. In Frame Buffer the positions are called picture elements or pixels. Beam refreshing is of two types. First is horizontal retracing and second is vertical retracing. When the beam starts from the top left corner and reaches the bottom right scale, it will again return to the top left side called at vertical retrace. Then it will again more horizontally from top to bottom call as horizontal retracing.\n
        </string>

    <string name="graphics_unit_1_part_6">
    <b>►Antialiasing problem and solution techniques.</b>\n\n
•Antialiasing is a technique used in computer graphics to remove the aliasing effect. The aliasing effect is the appearance of jagged edges or “jaggies” in a rasterized image (an image rendered using pixels). The problem of jagged edges technically occurs due to distortion of the image when scan conversion is done with sampling at a low frequency, which is also known as Undersampling. Aliasing occurs when real-world objects which comprise of smooth, continuous curves are rasterized using pixels.
Cause of anti-aliasing is Undersampling. Undersampling results in loss of information of the picture.\n\n

       <b> Methods of Antialiasing (AA) –</b>\n\n
Aliasing is removed using four methods: Using high-resolution display, Post filtering (Supersampling), Pre-filtering (Area Sampling), Pixel phasing. These are explained as following below.\n\n

        <b>•Using high-resolution display:</b>\n\n
One way to reduce aliasing effect and increase sampling rate is to simply display objects at a higher resolution. Using high resolution, the jaggies become so small that they become indistinguishable by the human eye. Hence, jagged edges get blurred out and edges appear smooth.\n
Practical applications:\n
For example retina displays in Apple devices, OLED displays have high pixel density due to which jaggies formed are so small that they blurred and indistinguishable by our eyes.\n\n

                <b>•Post filtering (Supersampling):</b>\n\n
In this method, we are increasing the sampling resolution by treating the screen as if it’s made of a much more fine grid, due to which the effective pixel size is reduced. But the screen resolution remains the same. Now, intensity from each subpixel is calculated and average intensity of the pixel is found from the average of intensities of subpixels. Thus we do sampling at higher resolution and display the image at lower resolution or resolution of the screen, hence this technique is called supersampling. This method is also known as post filtration as this procedure is done after generating the rasterized image.\n
Practical applications:\n
In gaming, SSAA (Supersample Antialiasing) or FSAA (full-scene antialiasing) is used to create best image quality. It is often called the pure AA and hence is very slow and has a very high computational cost. This technique was widely used in early days when better AA techniques were not available. Different modes of SSAA available are: 2X, 4X, 8X, etc. denoting that sampling is done x times (more than) the current resolution.\n

A better style of AA is MSAA (multisampling Antialiasing) which is a faster and approximate style of supersampling AA.It has lesser computational cost. Better and sophisticated supersampling techniques are developed by graphics card companies like CSAA by NVIDIA and CFAA by AMD.\n\n

                <b>•Pre filtering :</b>\n\n
In area sampling, pixel intensities are calculated proportional to areas of overlap of each pixel with objects to be displayed. Here pixel color is computed based on the overlap of scene’s objects with a pixel area.\n

For example: Suppose, a line passes through two pixels. The pixel covering bigger portion(90%) of line displays 90% intensity while less area(10%) covering pixel displays 10-15% intensity. If pixel area overlaps with different color areas, then the final pixel color is taken as an average of colors of the overlap area. This method is also known as pre-filtering as this procedure is done BEFORE generating the rasterized image. It’s done using some graphics primitive algorithms.\n
•Pixel phasing:\n
It’s a technique to remove aliasing. Here pixel positions are shifted to nearly approximate positions near object geometry. Some systems allow the size of individual pixels to be adjusted for distributing intensities which is helpful in pixel phasing.\n\n
    </string>


    <string name="graphics_unit_1_part_7">

          <b>►Video Memory</b>\n\n
        Video memory is memory located on the video card, in some cases located on the motherboard, that is accessible by the video and computer processor. With more video memory, the video card and computer are capable of handling more complex graphics at a faster rate.\n
        Like RAM in a computer, video memory temporarily stores data relating to graphics. As new graphics data comes into the video card, it replaces graphics data no longer needed in the video memory. When a computer is turned off, any graphics data in the video memory is removed.\n\n
    <b>►Frame Buffer</b>\n\n
    An area of memory used to hold the frame of data that is continuously being sent to the screen. The buffer is the size of the maximum image that can be displayed and may be a separate memory bank on the graphics card (display adapter) or a reserved part of regular memory. Sophisticated graphics systems are built with several memory planes, each holding one or more bits of the pixel.\n\n
    </string>
<!--    VB.Net UNIT 1 STRINGS-->
    <string name="firstsegmentvbunit1">
      <u><b>►DOT NET Framework</b></u>\n:-
        The .Net framework is a software development platform developed by Microsoft. The framework was meant to create applications,
        which would run on the Windows Platform. The first version of the .Net framework was released in the year 2002.\n
        The version was called .Net framework 1.0. The .Net framework has come a long way since then, and the current version is 4.7.1.\n\n

        <u>The .Net framework can be used to create both </u>- Form-based and Web-based applications. Web services can also be developed using the .Net framework.\n

         The framework also supports various programming languages such as Visual Basic and C#. So developers can choose and select the language
        to develop the required application. In this chapter, you will learn some basics of the .Net framework.\n\n




   <b><u>►Overview and Base Class Library</u></b>:-\n
The Framework Class Library or FCL provides the system functionality in the .NET Framework as it has various classes, data types, interfaces, etc. to perform multiple
functions and build different types of applications such as desktop applications, web applications, mobile applications, etc. The Framework Class Library is integrated
 with the Common Language Runtime (CLR) of the .NET framework and is used by all the .NET languages such as C#, F#, Visual Basic .NET, etc.\n\n

        <b>Categories in the Framework Class Library</b>>:-\n
    The functionality of the Framework Class Library can be broadly divided into three categories i.e utility features written in .NET, wrappers around the
        OS functionality and frameworks. These categories are not rigidly defined and there are many classes that may fit into more than one category.
Framwork-Class-Library-FCL-in-Dot-NET


<u>Details about the Categories in the Framework Class Library are given as follows</u>:\n\n

        1)<b>Utility Features</b>:- The utility features in the FCL includes various collection classes such as list, stack, queue, dictionary, etc. and also classes for more varied manipulations such as Regex class for regular expressions.\n

2)<b>Wrappers Around OS functionality</b>:- Some of the features in the FCL are wrappers around the underlying Windows OS functionality. These include the classes for using the file system, the classes to handle the network features, the
classes to handle I/O for console applications, etc.\n

3)<b>Frameworks</b>:- There are various frameworks available in the FCL to develop certain applications. For example, ASP.NET is used to develop web applications, Windows Presentation Foundation (WPF) is used to render user interfaces in
Windows applications and so on.\n\n




 <u><b>►MSIL</b></u>:-\n MSIL stands for Microsoft Intermediate Language. We can call it as Intermediate Language (IL) or Common Intermediate Language (CIL). During the compile time , the compiler convert the source code into Microsoft Intermediate
Language (MSIL) .Microsoft Intermediate Language (MSIL) is a CPU-independent set of instructions that can be efficiently converted to the native code. \n\n



<u><b>►Common Language Run Time (CLR)</b></u>\n:-
CLR is the basic and Virtual Machine component of the .NET Framework. It is the run-time enviornment in the .NET Framework that runs the codes and helps in making the development process easier by providing the various services.
Basically, it is responsible for managing the execution of .NET programs regardless of any .NET programming language. Internally, CLR implements the VES(Virtual Execution System) which is defined in the Microsoft’s implementation
 of the CLI(Common Language Infrastructure).The code that runs under the Common Language Runtime is termed as the Managed Code. In other words, you can say that CLR provides a managed execution enviornment for the .NET programs
by improving the security, including the cross language integration and a rich set of class libraries etc. CLR is present in everyn .NET framework verison\n\n</string>
    <string name="second_segment_vb_unit1">
         <b><u>►Events</u></b>:-\nAn event is an action or occurrence such as a mouse click, a key press, mouse movements, or any system-generated notification. A process communicates through events. For example, interrupts are system-generated events.
 When events occur, the application should be able to respond to it and manage it.\n\n



<b><u>► .NET Assemblies</u></b>:-\nAssemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.
 An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.
 Assemblies take the form of executable (.exe) or dynamic link library (.dll) files, and are the building blocks of .NET applications.
 They provide the common language runtime with the information it needs to be aware of type implementations.\n

In .NET Core and .NET Framework, you can build an assembly from one or more source code files. In .NET Framework, assemblies can contain one or more modules.
This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.\n\n
Assemblies have the following properties:\n\n

1.Assemblies are implemented as .exe or .dll files.\n

2.For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the global assembly cache (GAC). You must strong-name assemblies before you can include them in the GAC. For more information, see Strong-named assemblies.\n

3.Assemblies are only loaded into memory if they are required. If they are not used, they are not loaded. This means that assemblies can be an efficient way to manage resources in larger projects.\n

4.You can programmatically obtain information about an assembly by using reflection. For more information, see Reflection (C#) or Reflection (Visual Basic).\n

5.You can load an assembly just to inspect it by using the MetadataLoadContext class in .NET Core and the Assembly.ReflectionOnlyLoad or Assembly.ReflectionOnlyLoadFrom methods in .NET Core and .NET Framework.\n\n\n


<b>In .Net 3 types of Assemblies are available:\n\n</b>

        1. <u>Private Assemblies</u> : Private Assemblies are designed to be used by one application and
                                   must reside in that application\'s directory or subdirectory. \n

        2. <u>Shared Assemblies</u>: Microsoft offers the shared assembly for those components that must
                                  be distributed. It centered around two principles.
                                  Firstly, called side-by-side execution, allows the CLR to house multiple
                                  versions of the same component on a single machine.
                                  Secondly, termed binding, ensures that clients obtain the version of the
                                  component they expect. \n

        3. <u>Satellite Assembly</u>: A satellite Assembly is defined as an assembly with resources only, no
                                 executable code.\n

         <b><u>► Advantages of Assemblies over Predecessors</u></b>:-\n
Assemblies are designed to simplify application deployment and to solve versioning problems that can occur with component-based applications.\n
End users and developers are familiar with versioning and deployment issues that arise from today\’s component-based systems. Some end users have
experienced the frustration of installing a new application on their computer, only to find that an existing application has suddenly stopped working.
 Many developers have spent countless hours trying to keep all necessary registry entries consistent in order to activate a COM class\n
Many deployment problems have been solved by the use of assemblies in the .NET Framework. Because they are self-describing components that have no
dependencies on registry entries, assemblies enable zero-impact application installation. They also simplify uninstalling and replicating applications.
\n\n\n

        <u><b>► Dynamic Link Library (DLL)</b></u>>:-\n
A DLL is a library that contains code and data that can be used by more than one program at the same time. For example, in Windows operating systems,
the Comdlg32 DLL performs common dialog box related functions. Therefore, each program can use the functionality that is contained in this DLL to implement
an Open dialog box. This helps promote code reuse and efficient memory usage.\n
By using a DLL, a program can be modularized into separate components. For example, an accounting program may be sold by module. Each module can be loaded
into the main program at run time if that module is installed. Because the modules are separate, the load time of the program is faster, and a module is
only loaded when that functionality is requested.\n
Additionally, updates are easier to apply to each module without affecting other parts of the program. For example, you may have a payroll program, and the tax
rates change each year. When these changes are isolated to a DLL, you can apply an update without needing to build or install the whole program again.\n\n

        <u><b>► Namespaces</b></u>:-\n
Namespace is logical division of class, structure and interface OR way to organize your Visual Basic .NET code is through the use of namespaces.\n
Namespaces are a way of grouping type names and reducing the chance of name collisions.\n
The namespace with all the built-in functionality comes under System namespace. All other namespaces comes under this System namespace.\n\n

Declaration of Namespaces:\n
// Namespace Declaration in C#
using System;
using System.Data;
// Namespace Declaration in VB\n
imports system;\n
imports system.Data;\n\n
        <u><b>► Visual Studio IDE</b></u>:-

    </string>
    <string name="arrayvbunit3">An array stores a fixed-size sequential collection of elements of the same type. An array is
        used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n
        All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element\n\n\n</string>
    <string name="declaringarray">
    To declare an array in VB.Net, you use the Dim statement. For example\n
    1) Dim intData(30)	  — an array of 31 elements\n
    2)Dim strData(20) As String	— an array of 21 strings\n
    3)Dim twoDarray(10, 20) As Integer	—a two dimensional array of integers\n
        4)Dim ranges(10, 100)	 —a two dimensional array\n\n\n
    You can also initialize the array elements while declaring the array. For example:-\n\n
        Dim intData() As Integer = {12, 16, 20, 24, 28, 32}\n
        "Dim names() As String = {\"mohit\",\"navdeep\"}"\n\n


    </string>
    <string name="dynamic_arrays"><B><U>Dynamic Arrays</U></B></string>
    <string name="dynamicarray">
        Dynamic arrays are arrays that can be dimensioned and re-dimensioned as par the need of the program.
        You can declare a dynamic array using the ReDim statemen\n
       Syntax for ReDim statement −\n
        ReDim [Preserve] arrayname(subscripts)\n
        Where,\n\n
        The Preserve keyword helps to preserve the data in an existing array, when you resize it.\n
        <B>arrayname</B> is the name of the array to re-dimension\n
             subscripts specifies the new dimension.\n\n



    </string>
    <string name="test"><B><u>arrayname</u></B> is the name of the array to re-dimension</string>
    <string name="array"><B><u>Array</u></B></string>

    <string name="creating_array_in_vb_net"><b><u>Creating array in vb.net:-</u></b>\n\n</string>
    <string name="arrayclass"><b><u>The Array Class</u></b>\n
     The Array class is the base class for all the arrays in VB.Net. It is defined in the System namespace. The Array class provides various properties and methods to work with arrays.\n
        <u>Properties of the Array Class:-</u>\n
The following table provides some of the most commonly used properties of the Array class −\n\n

    </string>
    <string name="adonet">ADO.NET provides a bridge between the front end controls and the back end database. The ADO.NET objects encapsulate all the data access operations and the controls interact with these objects to display data, thus hiding the details of movement of data.\n\n
    The following figure shows the ADO.NET objects at a glance:\n


    </string>
    <string name="unit2vbvar">A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in VB.Net has a specific type, which determines the size and layout of the variable\'s memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.\n
        We have already discussed various data types. The basic value types provided in VB.Net can be categorized as \n\n
        1)Integral types	    :- SByte, Byte, Short, UShort, Integer, UInteger, Long, ULong and Char\n
        2)Floating point type :- Single and Double\n
        3)Decimal types       :- Decimal\n
        4)Boolean types       :-True or False values, as assigned\n
        5)Date types	   :-Date\n\n\n
        VB.Net also allows defining other value types of variable like Enum and reference types of variables like Class. \n\n











    </string>
    <string name="variable_declaration_in_vb_net">Variable Declaration in VB.Net</string>
    <string name="vardeclarationunit2">The Dim statement is used for variable declaration and storage allocation for one or more variables. The Dim statement is used at module, class, structure, procedure or block level.\n\n
    Syntax for variable declaration in VB.Net is −\n
        [  attributelist ] [ accessmodifier ] [[ Shared ] [ Shadows ] | [ Static ]]\n
            [ ReadOnly ] Dim [ WithEvents ] variablelist\n\\n
Where\n\n
        #attributelist is a list of attributes that apply to the variable. Optional.\n
        #accessmodifier defines the access levels of the variables, it has values as - Public, Protected, Friend, Protected Friend and Private. Optional.\n
        #Shared declares a shared variable, which is not associated with any specific instance of a class or structure, rather available to all the instances of the class or structure. Optional.\n
        #Shadows indicate that the variable re-declares and hides an identically named element, or set of overloaded elements, in a base class. Optional.\n
        #Static indicates that the variable will retain its value, even when the after termination of the procedure in which it is declared. Optional.\n
        #ReadOnly means the variable can be read, but not written. Optional.\n
        #WithEvents specifies that the variable is used to respond to events raised by the instance assigned to the variable. Optional.\n
        #Variablelist provides the list of variables declared.\n\n
        Some valid variable declarations along with their definition are shown here −\n\n

Dim StudentID As Integer\n
Dim StudentName As String\n
Dim Salary As Double\n
Dim count1, count2 As Integer\n
Dim status As Boolean\n
Dim exitButton As New System.Windows.Forms.Button\n
Dim lastTime, nextTime As Date\n




















    </string>
    <string name="datatypenvmet">Data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.\n


</string>
    <string name="datatypeexvb">VB.Net provides a wide range of data types. The following table shows all the data types available −\n

    Boolean	,Byte,Char,Date,Decimal,Double,Integer,Long	,Object,SByte,Short,Single,Strin,UInteger,ULong,User-Defined,UShort	\n\n







    </string>
    <string name="operatorsvbnet">
        An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. VB.Net is rich in built-in operators and provides following types of commonly used operators −\n

# Arithmetic Operators\n

# Comparison Operators\n

# Logical/Bitwise Operators\n

# Bit Shift Operators\n

# Assignment Operators\n

# Miscellaneous Operators\n





    </string>
    <string name="vbnetifelse">An If statement can be followed by an optional Else statement, which executes when the Boolean expression is false.\n\
    Syntax\n\n
        The syntax of an If...Then... Else statement in VB.Net is as follows −\n
        If(boolean_expression)Then\n
           statement(s) will execute if the Boolean expression is true \n
        Else\n
          statement(s) will execute if the Boolean expression is false \n
        End If\n\n\n

        If the Boolean expression evaluates to true, then the if block of code will be executed, otherwise else block of code will be executed.\n
    </string>
    <string name="ifelseifelseinvb">An If statement can be followed by an optional Else if…Else statement, which is very useful to test various conditions using single If…Else If statement.\n
    When using If… Else If... Else statements, there are few points to keep in mind.\n
        1.An If can have zero or one Else\'s and it must come after an Else Ifs.\n
        2.An If can have zero to many Else If\'s and they must come before the Else.\n
        3.Once an Else if succeeds, none of the remaining Else If\'s or Else\'s will be tested.\n\n


        The syntax of an if...else if...else statement in VB.Net is as follows −\n\n


If(boolean_expression 1)Then\n
           \' Executes when the boolean expression 1 is true \n
        ElseIf( boolean_expression 2)Then\n
            Executes when the boolean expression 2 is true \n
        ElseIf( boolean_expression 3)Then\n
         Executes when the boolean expression 3 is true \n
        Else \n
        \'  executes when the none of the above condition is true \n
        End If\n\n
    </string>
    <string name="selectvbcase">A Select Case statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each select case.\n
    The syntax for a Select Case statement in VB.Net is as follows −\n
        Select [ Case ] expression\n
           [ Case expressionlist\n
              [ statements ] ]\n
           [ Case Else\n
              [ elsestatements ] ]\n
        End Select\n










    </string>
    <string name="fornextvb">It repeats a group of statements a specified number of times and a loop index counts the number of loop iterations as the loop executes.\n
    The syntax for this loop construct is −\n\n
For counter [ As datatype ] = start To end [ Step step ]\n
           [ statements ]\n
           [ Continue For ]\n
           [ statements ]\n
           [ Exit For ]\n
   [ statements ]\n
        Next [ counter ]\n

       Module loops\n
   Sub Main()\n
      Dim a As Byte\n
      \' for loop execution\n
      For a = 10 To 20\n
          Console.WriteLine("value of a: {0}", a)\n
      Next\n
      Console.ReadLine()\n
   End Sub\n
End Module\n\n\n\n
When the above code is compiled and executed, it produces the following result −\n\n

value of a: 10\n
value of a: 11\n
value of a: 12\n
value of a: 13\n
value of a: 14\n
value of a: 15\n
value of a: 16\n

value of a: 17\n
value of a: 18\n
value of a: 19\n
value of a: 20\n









    </string>
    <string name="eachnextloop">


        It repeats a group of statements for each element in a collection. This loop is used for accessing and manipulating all elements in an array or a VB.Net collection.\n\n

The syntax for this loop construct is −\n\n

For Each element [ As datatype ] In group\n
   [ statements ]\n
   [ Continue For ]\n
   [ statements ]\n
   [ Exit For ]\n
   [ statements ]\n
Next [ element ]\n
Example\n
Live Demo\n
Module loops\n
   Sub Main()\n
      Dim anArray() As Integer = {1, 3, 5, 7, 9}\n
      Dim arrayItem As Integer\n
        \'displaying the values\n\n\n

      For Each arrayItem In anArray\n
         Console.WriteLine(arrayItem)\n

      Next\n
      Console.ReadLine()\n
   End Sub\n
End Module\n
When the above code is compiled and executed, it produces the following result −\n\n

1\n
3\n
5\n
7\n
9\n





    </string>
    <string name="doloopinvb">
       do loop-\n

        it repeats the enclosed block of statements while a Boolean condition is True or until the condition becomes True. It could be terminated at any time with the Exit Do statement.\n\n

The syntax for this loop construct is −\n\n

Do { While | Until } condition\n
   [ statements ]\n
   [ Continue Do ]\n
   [ statements ]\n
   [ Exit Do ]\n
   [ statements ]\n

Loop\n
-or-\n

Do\n
   [ statements ]\n
   [ Continue Do ]\n
   [ statements ]\n
   [ Exit Do ]\n
   [ statements ]\n
Loop { While | Until } condition\n

Example\n\n
Module loops\n
   Sub Main()\n
      \' local variable definition \n
      Dim a As Integer = 10\n
      \'do loop execution \n
      Do\n
          Console.WriteLine("value of a: {0}", a)\n
          a = a + 1\n
      Loop While (a &lt; 20)\n
      Console.ReadLine()\n
   End Sub\n
End Module\n
When the above code is compiled and executed, it produces the following result −\n\n

value of a: 10\n
value of a: 11\n
value of a: 12\n
value of a: 13\n
value of a: 14\n
value of a: 15\n
value of a: 16\n
value of a: 17\n
value of a: 18\n
value of a: 19\n
The program would behave in same way, if you use an Until statement, instead of While −\n\n


Module loops\n
   Sub Main()\n
      \' local variable definition\n
      Dim a As Integer = 10\n
     \'do loop execution\n

      Do\n\n
          Console.WriteLine("value of a: {0}", a)\n
          a = a + 1\n
      Loop Until (a = 20)\n
      Console.ReadLine()\n
   End Sub\n
End Module\n
When the above code is compiled and executed, it produces the following result −\n\n

value of a: 10\n
value of a: 11\n
value of a: 12\n
value of a: 13\n
value of a: 14\n
value of a: 15\n
value of a: 16\n
value of a: 17\n
value of a: 18\n
value of a: 19\n




    </string>
    <string name="whilenwetloop">
        While While next \n\n
         It    executes a series of statements as long as a given condition is True.\n\n

The syntax for this loop construct is −\n\n

While condition\n
   [ statements ]\n
   [ Continue While ]\n
   [ statements ]\n
   [ Exit While ]\n
   [ statements ]\n
End While\n
Here, statement(s) may be a single statement or a block of statements. The condition may be any expression, and true is logical true. The loop iterates while the condition is true.\n\n


    </string>



<!--    VB.Net UNIT 4-->

    <string name="controls"> <b><u>CONTROLS</u></b>\n\n

        An object is a type of user interface element you create on a Visual Basic form by using a toolbox control. In fact, in Visual Basic, the form itself is an object. Every Visual Basic control consists of three important elements − \n\n

-Properties which describe the object,\n\n

-Methods cause an object to do something and\n\n

-Events are what happens when an object does something.\n\n

<h1><b>Control Properties\n\n</b></h1>
All the Visual Basic Objects can be moved, resized or customized by setting their properties. A property is a value or characteristic held by a Visual Basic object, such as Caption or Fore Color.

Properties can be set at design time by using the Properties window or at run time by using statements in the program code.

Object. Property = Value
Where

Object is the name of the object you\'re customizing.

Property is the characteristic you want to change.

Value is the new property setting.

For example,

Form1.Caption = "Hello"
You can set any of the form properties using Properties Window. Most of the properties can be set or read during application execution. You can refer to Microsoft documentation for a complete list of properties associated with different controls and restrictions applied to them.

    </string>

    <string name="Radio_Button">

        <b><u>RADIO BUTTON</u></b>\n\n
        The RadioButton control is used to provide a set of mutually exclusive options. The user can select one radio button in a group. If you need to place more than one group of radio buttons in the same form, you should place them in different container controls like a GroupBox control.\n\n
        The Checked property of the radio button is used to set the state of a radio button. You can display text, image or both on radio button control. You can also change the appearance of the radio button control by using the Appearance property.\n\n

        <u>Properties of the RadioButton Control</u>\n\n
The following are some of the commonly used properties of the RadioButton control −\n\n

1.
Appearance\n

Gets or sets a value determining the appearance of the radio button.\n\n

2.
AutoCheck\n

Gets or sets a value indicating whether the Checked value and the appearance of the control automatically change when the control is clicked.\n\n

3.
CheckAlign\n

Gets or sets the location of the check box portion of the radio button.\n\n

4.
Checked\n

Gets or sets a value indicating whether the control is checked.\n\n

5.
Text\n

Gets or sets the caption for a radio button.\n\n

6.
TabStop\n

Gets or sets a value indicating whether a user can give focus to the RadioButton control using the TAB key.\n\n
    </string>

    <string name="text_box">
        <u><b>TEXT BOX</b></u>
         Text box controls allow entering text on a form at runtime. By default, it takes a single line of text, however, you can make it accept multiple texts and even add scroll bars to it.\n\n

        The Properties of the TextBox Control
The following are some of the commonly used properties of the TextBox control −\n\n

1.
AcceptsReturn\n

Gets or sets a value indicating whether pressing ENTER in a multiline TextBox control creates a new line of text in the control or activates the default button for the form.\n\n


2.
AutoCompleteCustomSource\n

Gets or sets a custom System.Collections.Specialized.StringCollection to use when the AutoComplete Source property is set to CustomSource.\n\n

3.
AutoCompleteMode\n

Gets or sets an option that controls how automatic completion works for the TextBox.\n\n

4.
AutoCompleteSource\n

Gets or sets a value specifying the source of complete strings used for automatic completion.\n\n

5.
CharacterCasing\n

Gets or sets whether the TextBox control modifies the case of characters as they are typed.\n\n

6.
Font\n

Gets or sets the font of the text displayed by the control.\n\n

        The Methods of the TextBox Control \n
The following are some of the commonly used methods of the TextBox control −\n\n

1.
AppendText\n

Appends text to the current text of a text box.\n\n

2.
Clear\n

Clears all text from the text box control.\n\n

3.
Copy\n

Copies the current selection in the text box to the Clipboard.\n\n

4.
Cut\n

Moves the current selection in the text box to the Clipboard.\n\n

5.
Paste\n

Replaces the current selection in the text box with the contents of the Clipboard.\n\n

6.
Paste(String)\n

Sets the selected text to the specified text without clearing the undo buffer.\n\n

7.
ResetText\n

Resets the Text property to its default value.\n\n

8.
ToString\n

Returns a string that represents the TextBoxBase control.\n\n

9.
Undo\n

Undoes the last edit operation in the text box.\n\n

    </string>
    <string name="Masked_text_box">
        <u><b>MASKED TEXT BOX</b></u>\n\n
        The .NET MaskedTextBox control provides a mechanism to validate user input on a Form. For example, if you need a TextBox that should accept dates in a certain format, you should set the masking in the MaskedTextBox. The MaskedTextBox uses the MaskedTextProvider mask syntax. The mask is used to distinguish between proper and improper user input. More on the Mask Syntax later.\n\n

Key Properties of a MaskedTextBox\n\n
1.MaskedTextBox.AllowPromptAsInput\n
The MaskedTextBox.AllowPromptAsInput Property determines whether PromptChar can be entered as valid data by the user. More on the PromptChar Property later.\n\n

2.AsciiOnly\n
The MaskedTextBox.AsciiOnly Property determines if a MaskedTextBox control accepts characters outside of the ASCII character set. If you do not know what ASCII is, please visit this link.\n\n

3.BeepOnError\n
The MaskedTextBox.BeepOnError Property raises the system beep for each key stroke that it rejects.\n\n

4.CutCopyMaskFormat\n
The MaskedTextBox.CutCopyMaskFormat Property determines if literals and prompt characters are copied to the Clipboard.\n\n

5.HidePromptOnLeave\n
The MaskedTextBox.HidePromptOnLeave Property indicates whether the prompt characters in the input mask are hidden when the MaskedTextBox loses focus.\n\n
    </string>

    <string name="richTextBox">
        <u><b>RICH TEXT BOX</b></u>\n\n

        A RichTextBox control is an advanced text box that provides text editing and advanced formatting features including loading rich text format (RTF) files.\n\n

In this article, I will demonstrates how create and use various features of Windows Forms RichTextBox control.\n\n



<u>Creating a RichTextBox</u>\n\n

We can create a RichTextBox control using a Forms designer at design-time or using the RichTextBox class in code at run-time.\n\n



To create a RichTextBox control at design-time, you simply drag and drop a RichTextBox control from Toolbox onto a Form in Visual Studio. Once a RichTextBox is added to a Form, you can move it around and resize it using mouse and set its properties and events.\n\n

Creating a RichTextBox control at run-time is merely a work of creating an instance of RichTextBox class, set its properties and add RichTextBox class to the Form controls.\n\n

First step to create a dynamic RichTextBox is to create an instance of RichTextBox class. The following code snippet creates a RichTextBox control object.\n\n

Dim dynamicRichTextBox As New RichTextBox()\n\n



In the next step, you may set properties of a RichTextBox control. The following code snippet sets size, location, background color, foreground color, Text, Name, and Font properties of a RichTextBox.\n\n

dynamicRichTextBox.Location = New Point(20, 20)\n\n

dynamicRichTextBox.Width = 300\n\n

dynamicRichTextBox.Height = 200\n\n

        Set background and foreground\n\n

dynamicRichTextBox.BackColor = Color.Red\n\n

dynamicRichTextBox.ForeColor = Color.Blue\n\n

dynamicRichTextBox.Text = "I am Dynamic RichTextBox"\n\n



dynamicRichTextBox.Name = "DynamicRichTextBox"\n\n

dynamicRichTextBox.Font = New Font("Georgia", 16)\n\n

Once a RichTextBox control is ready with its properties, next step is to add the RichTextBox control to the Form. To do so, we use Form.Controls.Add method. The following code snippet adds a RichTextBox control to the current Form.\n\n

Controls.Add(dynamicRichTextBox)\n\n
    </string>

    <string name="numericupdown">
        <b><u>NUMERIC UP-DOWN</u></b>\n\n

        NumericUpDown is basically countered that the user can input a number within the specified range. With the Help of NumericUpDown Control, we can enter numeric values, with advanced features like up-down buttons and accelerating auto-repeat.\n\n
How to use NumericUpDown Control\n\n

Drag and drop NumericUpDown Control from the toolbox on window Form.\n
        By Default Maximum and Minimum value in NumericUpDown Control is set 100 and 0 respectively. You can also set Maximum and Minimum value in NumericUpDown Control. To show the value in NumericUpDown.\n\n


        Run the project-:\n\n

        When you select the value in NumericUpDown1 then the ValueChanged event will fire and selected value will show in the TextBox.\n\n

        <u> NumericUpDown Control Properties</u>\n\n

DecimalPlaces:  Gets or sets the number of decimal places to display in NumericUpDown Control.\n\n

UpDownAlign:  Set positions the arrow buttons on the left or the right side of the NumericUpDown. Default value is Right.\n\n

Increment:  Gets or sets the value to increment or decrement the NumericUpDown.\n\n

    </string>
    <string name="treeView">
        <u><b>TREE VIEW</b></u>
        The TreeView control is used to display hierarchical representations of items similar to the ways the files and folders are displayed in the left pane of the Windows Explorer. Each node may contain one or more child nodes.\n\n

        The user can expand the TreeNode by clicking the plus sign (+) button, if one is displayed next to the TreeNode, or you can expand the TreeNode by calling the TreeNode.Expand method. When a parent node is expanded, its child nodes are visible. You can also navigate through tree views with various properties: FirstNode, LastNode, NextNode, PrevNode, NextVisibleNode, PrevVisibleNode.\n\n

The fullpath method of treeview control provides the path from root node to the selected node.\n\n

TreeView1.SelectedNode.FullPath\n\n

Tree nodes can optionally display check boxes. To display the check boxes, set the CheckBoxes property of the TreeView to true.\n\n

TreeView1.CheckBoxes = True\n\n
    </string>

<!--    OS Unit 1 Started here......-->














































































































































































































































































































































    <string name="OS_unit_1_part_1">
       <b> ►What is an OS?</b>\n\n
An operating system is a program that controls the execution of application programs and acts as an interface between the user of a computer and the computer hardware.\n\n

Functions of Operating system – Operating system performs three functions:\n
1.	Convenience: An OS makes a computer more convenient to use.\n
2.	Efficiency: An OS allows the computer system resources to be used in an efficient manner.\n
3.	Ability to Evolve: An OS should be constructed in such a way as to permit the effective development,\n testing and introduction of new system functions at the same time without interfering with service.\n\n\n
very general-purpose computer consists of the hardware, operating system, system programs, and application programs. The hardware consists of memory, CPU, ALU, and I/O devices, peripheral device, and storage device. System program consists of compilers, loaders, editors, OS, etc. The application program consists of business programs, database programs.
    </string>


    <string name="OS_unit_1_part_2">

        <b>	►What are the Types of OS?</b>\n\n

        <b>1.Batch Operating System –</b>\n
        This type of operating system does not interact with the computer directly. There is an operator which takes similar jobs having same requirement and group them into batches. It is the responsibility of operator to sort the jobs with similar needs.\n

        <b>Advantages of Batch Operating System:</b>\n
        •	It is very difficult to guess or know the time required by any job to complete. Processors of the batch systems know how long the job would be when it is in queue\n
•	Multiple users can share the batch systems\n
•	The idle time for batch system is very less\n\n

        <b>Disadvantages of Batch Operating System:</b>\n

        •	The computer operators should be well known with batch systems\n
•	Batch systems are hard to debug\n
•	It is sometime costly\n
•	The other jobs will have to wait for an unknown time if any job fails\n
    </string>

    <string name="OS_unit_1_part_3">
        <b>2.Multiprogramming OS</b>\n\n
        Sharing the processor, when two or more programs reside in memory at the same time, is referred as multiprogramming. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute.\n
•   An OS does the following activities related to multiprogramming.

•   The operating system keeps several jobs in memory at a time.\n

•   This set of jobs is a subset of the jobs kept in the job pool.\n

•   The operating system picks and begins to execute one of the jobs in the memory.\n

•   Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.\n\n

        <b>Advantages</b>\n
•   High and efficient CPU utilization.\n
•   User feels that many programs are allotted CPU almost simultaneously.\n\n
        <b>Disadvantages</b>\n
•   CPU scheduling is required.\n
•   To accommodate many jobs in memory, memory management is required.\n
    </string>

    <string name="OS_unit_1_part_4">
        <b>2.Multiuser OS</b>\n\n
        A multi user operating system is that which handles and controls multiple users attached to a single computer. There are many benefits and disadvantages of multi user operating system that we will discuss.\n

        <b>Advantages</b>\n
•  Printing jobs in the office or library can be best handled by multi user operating system. Normal OS cannot do the same job as printing can be mismatched.\n
•Each user can access same document on own pc. For example if one computer has a song or movie then other computers attached with it will play that song or movie on their pc also.\n
•Airlines also use this system and ticket reservation is also done by this system.\n
•Teachers and library staff also use multi user operating system for handling books and for searching books. The book record is stored in one computer and other terminals access to single resource to query the books.\n
•If one computer in the network gets error then other computers not get affected and that system handle this efficiently.\n\n
        <b>Disadvantages</b>\n
       • If you have computer that has private information then sharing your computer with multiple users is dangerous.\n
•If one computer get attacked by a virus then other computers also get suffered.\n
•Your computer information will be shared to other users also.\n
•Creating multiple accounts on single computer sometimes not fit to users so it is better to have multiple computers for each user.\n\n\n
    </string>

    <string name="OS_unit_1_part_5">
        <b>2.Multitasking OS</b>\n\n
        <b>Note : Multitaking OS is also known as Timesharing OS.</b>\n
        Each task is given some time to execute, so that all the tasks work smoothly. Each user gets time of CPU as they use single system. These systems are also known as Multitasking Systems. The task can be from single user or from different users also. The time that each task gets to execute is called quantum. After this time interval is over OS switches over to next task.\n
        <b>Advantages</b>\n
•  Each task gets an equal opportunity\n
•Less chances of duplication of software\n
•CPU idle time can be reduced\n\n
        <b>Disadvantages</b>\n
•Reliability problem.
•One must have to take care of security and integrity of user programs and data.
•Data communication problem.
    </string>

    <string name="OS_unit_1_part_6">
<b>	►What is Spooling ?</b>\n\n
        •Spooling refers to simultaneous peripheral operations on-line, spooling refers to putting jobs in a buffer, a special area in memory or on a disk where a device can access them when it is ready.\n
•Spooling is useful because devices access data at different rates.\n
•The buffer provides a waiting station where data can rest while the slower device catches up\n
•Spooling also lets you place a number of print jobs on a queue instead of waiting for each one to finish before specifying the next one.\n\n\n
    </string>

    <string name="OS_unit_1_part_7">

            <b>	►What are Real Time operating Systems ? </b>\n\n
        A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing.

Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.\n\n\n


        <b>	► What are Distributed operating Systems ? </b>\n\n
        Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.\n
        The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on.\n\n

        <b>Advantages</b>\n
•With resource sharing facility, a user at one site may be able to use the resources available at another.\n
•Speedup the exchange of data with one another via electronic mail.\n
•If one site fails in a distributed system, the remaining sites can potentially continue operating.\n
•Better service to the customers.\n
•Reduction of the load on the host computer.\n
•Reduction of delays in data processing.\n\n\n
    </string>


    <string name="OS_unit_1_part_8">
<b>	►What are the Operating System concepts ?</b>\n\n
        <b>1 — Processes and Process Management</b>\n
A process is basically a program in execution. The execution of a process must progress in a sequential fashion. To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.\n\n

        <b>2 — Threads and Concurrency</b>\n
A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history.\n
A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that.\n\n

          <b>3 — Scheduling</b>\n
The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.\n\n


        <b>4 —Memory Management</b>\n
Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution.\n\n


        <b>5 — I/O Management</b>\n
One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc.\n\n
    </string>


    <string name="OS_unit_1_part_9">\n\n

        <b>►What are Operating System Services ?</b>\n

        An Operating System provides services to both the users and to the programs.\n\n

•It provides programs an environment to execute.\n
•It provides users the services to execute the programs in a convenient manner.\n
Following are a few common services provided by an operating system −\n

•Program execution\n
•I/O operations\n
•File System manipulation\n
•Communication\n
•Error Detection\n
•Resource Allocation\n
•Protection\n\n\n
        <b>1.Program execution</b>\n\n
•Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process.\n\n

A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management −\n

•Loads a program into memory.\n
•Executes the program.\n
•Handles program\'s execution.\n
•Provides a mechanism for process synchronization.\n
•Provides a mechanism for process communication.\n
•Provides a mechanism for deadlock handling.\n\n\n
<b>2.I/O Operation</b>\n\n
An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users.\n\n

An Operating System manages the communication between user and device drivers.\n

•I/O operation means read or write operation with any file or any specific I/O device.\n
•Operating system provides the access to the required I/O device when required.\n\n\n
        <b>3.File system manipulation</b>\n\n

A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods.\n

A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management −\n

•Program needs to read a file or write a file.\n
•The operating system gives the permission to the program for operation on file.\n
•Permission varies from read-only, read-write, denied and so on.\n
•Operating System provides an interface to the user to create/delete files.\n
•Operating System provides an interface to the user to create/delete directories.\n
•Operating System provides an interface to create the backup of file system.\n\n\n

        <b>4.Communication</b>\n\n
In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network.\n

The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication −\n

•Two processes often require data to be transferred between them\n
•Both the processes can be on one computer or on different computers, but are connected through a computer network.\n
•Communication may be implemented by two methods, either by Shared Memory or by Message Passing.\n\n\n

                <b>5.Error handling</b>\n\n

Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling \n

•The OS constantly checks for possible errors.\n
•The OS takes an appropriate action to ensure correct and consistent computing.\n\n\n

        <b>6.Resource Management</b>\n\n
In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management −\n

•The OS manages all kinds of resources using schedulers.\n
•CPU scheduling algorithms are used for better utilization of CPU.\n\n\n

                <b>7.Protection</b>\n\n
Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other\'s activities.\n

Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection −\n

•The OS ensures that all access to system resources is controlled.\n
•The OS ensures that external I/O devices are protected from invalid access attempts.\n
•The OS provides authentication features for each user by means of passwords.\n
    </string>


    <!--    OS Unit 2 Started here ....-->

    <string name="OS_unit_2_part_1">\n\n
       <b> ►Process</b>\n\n
•A process is basically a program in execution. The execution of a process must progress in a sequential fashion.\n
•A process is defined as an entity which represents the basic unit of work to be implemented in the system.\n
•To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.\n
•When a program is loaded into the memory and it becomes a process, it can be divided into four sections ─ stack, heap, text and data. The following image shows a simplified layout of a process inside main memory −\n
    </string>

    <string name="OS_unit_2_part_2">\n\n
       <b> ►Process Management </b>\n\n
Process managements involve the execution of various tasks such as creation of processes, scheduling of processes, management of deadlock, and termination of processes. It is responsibility of operating system to manage all the running processes of the system. Operating system manages processes by performing tasks such as resource allocation and process scheduling. When a process runs on computer device memory and CPU of computer are utilized. The operating system also has to synchronize the different processes of computer system.\n\n

A process consists of set of instruction to be executed called process code. A process is also associated with some data that is to be processed. The resources that a process required for its execution is called process components. There is also a state that is associated with a process at a particular instant of time called process state. Similar to these concepts, there are number of concepts associated with the process management function of an operating system. Some of those concepts are given as following.\n

1.Process State\n
2.Process Control Block (PCB)\n
3.Process Operations\n
4.Process Scheduling\n
5.Process Synchronization\n
6.Inter process Communication\n
7.Deadlock\n\n

               <b> ►Process states </b>\n\n
A process state can be defined as the condition of process at a particular instant of time. Process state defines the current position of process. This help to get detail of our process at a particular instant. There are basically seven states of process in operating system. The following are the seven states of process:\n\n

        <b> 1.New</b>\n\n
When any program is calls from secondary memory or calls from hard disk to primary memory or RAM then the new process is created. Basically it specified the time when a process is created.\n

        <b>2.Ready </b>\n
In this time interval the state of the process is loaded into the primary memory and ready for execution.\n

        <b>3.Waiting </b>\n
In this sate the process is kept on hold and other process are allowed to start 0their execution. In other words, it specifies the time interval when a process waits for the allocation of CPU time and the other resources for its execution.\n

        <b>4.Executing </b>\n
This is the main state of any process in this state the process is executing. In other words, it is the time interval when a process is being executed by CPU.\n

        <b>5.Blocked </b>\n
It specifies the time interval when a process is waiting for an event like input / output operations to complete.\n

        <b>6.Suspended </b>\n
It specifies the time when a process is ready for execution but has not been placed in the ready queue by operating system.\n

        <b>7.Terminated </b>\n
It specifies the time when a process is terminated or ended and all the resources that are utilized by process and memory that is utilized by the process are free.\n\n
    </string>


    <string name="OS_unit_2_part_3">\n\n
    <b> ►    Process Control Block (PCB)</b>\n\n

    A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process.\n
        The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB −
    </string>

    <string name="OS_unit_2_part_4">\n\n
    <b> ► Process Scheduling </b>\n\n

    The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.

Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.\n\n

        The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue.\n

The Operating System maintains the following important process scheduling queues −\n

•Job queue − This queue keeps all the processes in the system.\n

•Ready queue − This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.\n

•Device queues − The processes which are blocked due to unavailability of an I/O device constitute this queue.\n

        The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU.\n\n

    </string>

    <string name="OS_unit_2_part_5">\n\n
    <b> ► CPU scheduling</b>\n\n

    CPU scheduling is a process which allows one process to use the CPU while the execution of another process is on hold(in waiting state) due to unavailability of any resource like I/O etc, thereby making full use of CPU. The aim of CPU scheduling is to make the system efficient, fast and fair.
Whenever the CPU becomes idle, the operating system must select one of the processes in the ready queue to be executed. The selection process is carried out by the short-term scheduler (or CPU scheduler). The scheduler selects from among the processes in memory that are ready to execute, and allocates the CPU to one of them.\n\n

            <b>Types of CPU Scheduling</b>\n\n

CPU scheduling decisions may take place under the following four circumstances:\n

•When a process switches from the running state to the waiting state(for I/O request or invocation of wait for the termination of one of the child processes).\n
•When a process switches from the running state to the ready state (for example, when an interrupt occurs).\n
•When a process switches from the waiting state to the ready state(for example, completion of I/O).\n
•When a process terminates.\n\n

            <b>Scheduling Criteria</b>\n\n

                    <b>CPU Utilization</b>\n
To make out the best use of CPU and not to waste any CPU cycle, CPU would be working most of the time(Ideally 100% of the time). Considering a real system, CPU usage should range from 40% (lightly loaded) to 90% (heavily loaded.)\n
                            <b>•Throughput</b>\n

        It is the total number of processes completed per unit time or rather say total amount of work done in a unit of time. This may range from 10/second to 1/hour depending on the specific processes.\n
                            <b>•Turnaround Time</b>\n

It is the amount of time taken to execute a particular process, i.e. The interval from time of submission of the process to the time of completion of the process(Wall clock time).\n

                            <b>•Waiting Time</b>\n

The sum of the periods spent waiting in the ready queue amount of time a process has been waiting in the ready queue to acquire get control on the CPU.\n

                            <b>•Load Average</b>\n

It is the average number of processes residing in the ready queue waiting for their turn to get into the CPU.\n

                            <b>•Response Time</b>\n

Amount of time it takes from when a request was submitted until the first response is produced. Remember, it is the time till the first response and not the completion of process execution(final response).\n

In general CPU utilization and Throughput are maximized and other factors are reduced for proper optimization.\n\n

      <b> ►Scheduling Algorithms</b>\n\n
To decide which process to execute first and which process to execute last to achieve maximum CPU utilisation, computer scientists have defined some algorithms, they are:\n
•First Come First Serve(FCFS) Scheduling\n
•Shortest-Job-First(SJF) Scheduling\n
•Priority Scheduling\n
•Round Robin(RR) Scheduling\n
•Multilevel Queue Scheduling\n
•Multilevel Feedback Queue Scheduling\n\n
    </string>

</resources>
